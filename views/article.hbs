<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="/public/css/reset.css">
  <link rel="stylesheet" href="//at.alicdn.com/t/font_3172047_kmj3ju5mot.css">
  <link rel="stylesheet" href="/public/fonts/fonts.css">
  <link rel="stylesheet" href="/public/css/article.css">

</head>

<body>
  {{> head}}
  <main>
    <div class="content-wrap">
      <header class="head-wrap">
        <h1 class="title">官方标配！非常炫酷的 Linux 可视化管理工具，你值得拥有！</h1>
        <ul class="article-info">
          <li class="article-info-item author">
            <i class="iconfont icon-author"></i>
            <span>作者：Lionel</span>
          </li>
          <li class="article-info-item">
            <i class="iconfont icon-date"></i>
            <span>发布日期：2022/02/23</span>
          </li>
        </ul>
        <ul class="article-status">
          <li class="article-status-item views">
            <i class="iconfont icon-views"></i>
            <span>浏览数：1554</span>
          </li>
          <li class="article-status-item comments">
            <i class="iconfont icon-comments"></i>
            <span>评论数：454</span>
          </li>
          <li class="article-status-item likes">
            <i class="iconfont icon-likes"></i>
            <span>点赞数：154</span>
          </li>
        </ul>
      </header>
      <article class="article-content">
        <div class="markdown-body">
          <style>
            .markdown-body {
              word-break: break-word;
              line-height: 1.75;
              font-weight: 400;
              font-size: 16px;
              overflow-x: hidden;
              color: #333
            }

            .markdown-body h1,
            .markdown-body h2,
            .markdown-body h3,
            .markdown-body h4,
            .markdown-body h5,
            .markdown-body h6 {
              line-height: 1.5;
              margin-top: 35px;
              margin-bottom: 10px;
              padding-bottom: 5px
            }

            .markdown-body h1 {
              font-size: 24px;
              margin-bottom: 5px
            }

            .markdown-body h2,
            .markdown-body h3,
            .markdown-body h4,
            .markdown-body h5,
            .markdown-body h6 {
              font-size: 20px
            }

            .markdown-body h2 {
              padding-bottom: 12px;
              border-bottom: 1px solid #ececec
            }

            .markdown-body h3 {
              font-size: 18px;
              padding-bottom: 0
            }

            .markdown-body h6 {
              margin-top: 5px
            }

            .markdown-body p {
              line-height: inherit;
              margin-top: 22px;
              margin-bottom: 22px
            }

            .markdown-body img {
              max-width: 100%
            }

            .markdown-body hr {
              border: none;
              border-top: 1px solid #ddd;
              margin-top: 32px;
              margin-bottom: 32px
            }

            .markdown-body code {
              word-break: break-word;
              border-radius: 2px;
              overflow-x: auto;
              background-color: #fff5f5;
              color: #ff502c;
              font-size: .87em;
              padding: .065em .4em
            }

            .markdown-body code,
            .markdown-body pre {
              font-family: Menlo, Monaco, Consolas, Courier New, monospace
            }

            .markdown-body pre {
              overflow: auto;
              position: relative;
              line-height: 1.75
            }

            .markdown-body pre>code {
              font-size: 12px;
              padding: 15px 12px;
              margin: 0;
              word-break: normal;
              display: block;
              overflow-x: auto;
              color: #333;
              background: #f8f8f8
            }

            .markdown-body a {
              text-decoration: none;
              color: #0269c8;
              border-bottom: 1px solid #d1e9ff
            }

            .markdown-body a:active,
            .markdown-body a:hover {
              color: #275b8c
            }

            .markdown-body table {
              display: inline-block !important;
              font-size: 12px;
              width: auto;
              max-width: 100%;
              overflow: auto;
              border: 1px solid #f6f6f6
            }

            .markdown-body thead {
              background: #f6f6f6;
              color: #000;
              text-align: left
            }

            .markdown-body tr:nth-child(2n) {
              background-color: #fcfcfc
            }

            .markdown-body td,
            .markdown-body th {
              padding: 12px 7px;
              line-height: 24px
            }

            .markdown-body td {
              min-width: 120px
            }

            .markdown-body blockquote {
              color: #666;
              padding: 1px 23px;
              margin: 22px 0;
              border-left: 4px solid #cbcbcb;
              background-color: #f8f8f8
            }

            .markdown-body blockquote:after {
              display: block;
              content: ""
            }

            .markdown-body blockquote>p {
              margin: 10px 0
            }

            .markdown-body ol,
            .markdown-body ul {
              padding-left: 28px
            }

            .markdown-body ol li,
            .markdown-body ul li {
              margin-bottom: 0;
              list-style: inherit
            }

            .markdown-body ol li .task-list-item,
            .markdown-body ul li .task-list-item {
              list-style: none
            }

            .markdown-body ol li .task-list-item ol,
            .markdown-body ol li .task-list-item ul,
            .markdown-body ul li .task-list-item ol,
            .markdown-body ul li .task-list-item ul {
              margin-top: 0
            }

            .markdown-body ol ol,
            .markdown-body ol ul,
            .markdown-body ul ol,
            .markdown-body ul ul {
              margin-top: 3px
            }

            .markdown-body ol li {
              padding-left: 6px
            }

            .markdown-body .contains-task-list {
              padding-left: 0
            }

            .markdown-body .task-list-item {
              list-style: none
            }

            @media (max-width:720px) {
              .markdown-body h1 {
                font-size: 24px
              }

              .markdown-body h2 {
                font-size: 20px
              }

              .markdown-body h3 {
                font-size: 18px
              }
            }
          </style>
          <h2 data-id="heading-0">前言</h2>
          <p>四月份的时候，有位朋友去美团面试，他说被问到Redis与MySQL双写一致性如何保证？ 这道题其实就是在问缓存和数据库在双写场景下，一致性是如何保证的？本文将跟大家一起来探讨如何回答这个问题。</p>
          <p><img
              src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47e06ce80e7743028b8e79fb6cc35b0f~tplv-k3u1fbpfcp-watermark.awebp"
              alt="" loading="lazy" class="medium-zoom-image"></p>
          <ul>
            <li>公众号：<strong>捡田螺的小男孩</strong></li>
            <li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwhx123%2FJavaHome" target="_blank"
                rel="nofollow noopener noreferrer" title="https://github.com/whx123/JavaHome"
                ref="nofollow noopener noreferrer">github地址，感谢每一颗star</a></li>
          </ul>
          <h2 data-id="heading-1">谈谈一致性</h2>
          <p><img
              src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1353d15b66d43eab2cf8fd9aceb61d9~tplv-k3u1fbpfcp-watermark.awebp"
              alt="" loading="lazy" class="medium-zoom-image"></p>
          <p>一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。</p>
          <ul>
            <li><strong>强一致性</strong>：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大</li>
            <li>
              <strong>弱一致性</strong>：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态
            </li>
            <li>
              <strong>最终一致性</strong>：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型
            </li>
          </ul>
          <h2 data-id="heading-2">三个经典的缓存模式</h2>
          <p>缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据<strong>不一致性</strong>的问题。一般我们是如何使用缓存呢？有三种经典的缓存模式：</p>
          <ul>
            <li>Cache-Aside Pattern</li>
            <li>Read-Through/Write through</li>
            <li>Write behind</li>
          </ul>
          <h3 data-id="heading-3">Cache-Aside Pattern</h3>
          <p>Cache-Aside Pattern，即<strong>旁路缓存模式</strong>，它的提出是为了尽可能地解决缓存与数据库的数据不一致问题。</p>
          <h4 data-id="heading-4">Cache-Aside读流程</h4>
          <p><strong>Cache-Aside Pattern</strong>的读请求流程如下：</p>
          <p><img
              src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16e4b4c301cc44a09b3fe1938d9c6d89~tplv-k3u1fbpfcp-watermark.awebp"
              alt="Cache-Aside读请求" loading="lazy" class="medium-zoom-image"></p>
          <ol>
            <li>读的时候，先读缓存，缓存命中的话，直接返回数据</li>
            <li>缓存没有命中的话，就去读数据库，从数据库取出数据，放入缓存后，同时返回响应。</li>
          </ol>
          <h4 data-id="heading-5">Cache-Aside 写流程</h4>
          <p><strong>Cache-Aside Pattern</strong>的写请求流程如下：</p>
          <p><img
              src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b98a1c0f93cf442db57ac56b5b26c393~tplv-k3u1fbpfcp-watermark.awebp"
              alt="Cache-Aside写请求" loading="lazy" class="medium-zoom-image"></p>
          <p>更新的时候，先<strong>更新数据库，然后再删除缓存</strong>。</p>
          <h3 data-id="heading-6">Read-Through/Write-Through（读写穿透）</h3>
          <p><strong>Read/Write Through</strong>模式中，服务端把缓存作为主要数据存储。应用程序跟数据库缓存交互，都是通过<strong>抽象缓存层</strong>完成的。</p>
          <h4 data-id="heading-7">Read-Through</h4>
          <p><strong>Read-Through</strong>的简要流程如下</p>
          <p><img
              src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eca809755b242119757201af531b3e2~tplv-k3u1fbpfcp-watermark.awebp"
              alt="Read Through简要流程" loading="lazy" class="medium-zoom-image"></p>
          <ol>
            <li>从缓存读取数据，读到直接返回</li>
            <li>如果读取不到的话，从数据库加载，写入缓存后，再返回响应。</li>
          </ol>
          <p>
            这个简要流程是不是跟<strong>Cache-Aside</strong>很像呢？其实<strong>Read-Through</strong>就是多了一层<strong>Cache-Provider</strong>，流程如下：
          </p>
          <p><img
              src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60d3de199b5f41daa0ad464596fd404d~tplv-k3u1fbpfcp-watermark.awebp"
              alt="Read-Through流程" loading="lazy" class="medium-zoom-image"></p>
          <p>Read-Through实际只是在<strong>Cache-Aside</strong>之上进行了一层封装，它会让程序代码变得更简洁，同时也减少数据源上的负载。</p>
          <h4 data-id="heading-8">Write-Through</h4>
          <p><strong>Write-Through</strong>模式下，当发生写请求时，也是由<strong>缓存抽象层</strong>完成数据源和缓存数据的更新,流程如下：
            <img
              src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb1eaafc6ab14ca98fe603fad1fb7fc5~tplv-k3u1fbpfcp-watermark.awebp"
              alt="Write-Through流程" loading="lazy" class="medium-zoom-image">
          </p>
          <h3 data-id="heading-9">Write behind （异步缓存写入）</h3>
          <p><strong>Write
              behind</strong>跟<strong>Read-Through/Write-Through</strong>有相似的地方，都是由<code>Cache Provider</code>来负责缓存和数据库的读写。它两又有个很大的不同：<strong>Read/Write
              Through</strong>是同步更新缓存和数据的，<strong>Write
              Behind</strong>则是只更新缓存，不直接更新数据库，通过<strong>批量异步</strong>的方式来更新数据库。
          </p>
          <p><img
              src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81197a8c7a164b0b9a76b8380ae29a4b~tplv-k3u1fbpfcp-watermark.awebp"
              alt="Write behind流程" loading="lazy" class="medium-zoom-image"></p>
          <p>这种方式下，缓存和数据库的一致性不强，<strong>对一致性要求高的系统要谨慎使用</strong>。但是它适合频繁写的场景，MySQL的<strong>InnoDB Buffer
              Pool机制</strong>就使用到这种模式。</p>
          <h2 data-id="heading-10">操作缓存的时候，删除缓存呢，还是更新缓存？</h2>
          <p>一般业务场景，我们使用的就是<strong>Cache-Aside</strong>模式。
            有些小伙伴可能会问， <strong>Cache-Aside</strong>在写入请求的时候，为什么是<strong>删除缓存而不是更新缓存</strong>呢？</p>
          <p><img
              src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75b7c68482364471a922b713b35128f6~tplv-k3u1fbpfcp-watermark.awebp"
              alt="Cache-Aside写入流程" loading="lazy" class="medium-zoom-image"></p>
          <p>我们在操作缓存的时候，到底应该删除缓存还是更新缓存呢？我们先来看个例子：</p>
          <p><img
              src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbc52abea19746dd8db070253f3a4609~tplv-k3u1fbpfcp-watermark.awebp"
              alt="" loading="lazy" class="medium-zoom-image"></p>
          <ol>
            <li>线程A先发起一个写操作，第一步先更新数据库</li>
            <li>线程B再发起一个写操作，第二步更新了数据库</li>
            <li>由于网络等原因，线程B先更新了缓存</li>
            <li>线程A更新缓存。</li>
          </ol>
          <p>
            这时候，缓存保存的是A的数据（老数据），数据库保存的是B的数据（新数据），数据<strong>不一致</strong>了，脏数据出现啦。如果是<strong>删除缓存取代更新缓存</strong>则不会出现这个脏数据问题。
          </p>
          <p><strong>更新缓存相对于删除缓存</strong>，还有两点劣势：</p>
          <ul>
            <li>如果你写入的缓存值，是经过复杂计算才得到的话。更新缓存频率高的话，就浪费性能啦。</li>
            <li>在写数据库场景多，读数据场景少的情况下，数据很多时候还没被读取到，又被更新了，这也浪费了性能呢(实际上，写多的场景，用缓存也不是很划算了)</li>
          </ul>
          <h2 data-id="heading-11">双写的情况下，先操作数据库还是先操作缓存？</h2>
          <p><code>Cache-Aside</code>缓存模式中，有些小伙伴还是有疑问，在写入请求的时候，为什么是<strong>先操作数据库呢</strong>？为什么<strong>不先操作缓存</strong>呢？
          </p>
          <p>假设有A、B两个请求，请求A做更新操作，请求B做查询读取操作。
            <img
              src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a30ff3d1b8374d1b8508200566b4e1c6~tplv-k3u1fbpfcp-watermark.awebp"
              alt="image.png" loading="lazy" class="medium-zoom-image">
          </p>
          <ol>
            <li>线程A发起一个写操作，第一步del cache</li>
            <li>此时线程B发起一个读操作，cache miss</li>
            <li>线程B继续读DB，读出来一个老数据</li>
            <li>然后线程B把老数据设置入cache</li>
            <li>线程A写入DB最新的数据</li>
          </ol>
          <p>
            酱紫就有问题啦，<strong>缓存和数据库的数据不一致了。缓存保存的是老数据，数据库保存的是新数据</strong>。因此，<code>Cache-Aside</code>缓存模式，选择了先操作数据库而不是先操作缓存。
          </p>
          <h3 data-id="heading-12">缓存延时双删</h3>
          <p>有些小伙伴可能会说，不一定要先操作数据库呀，采用<strong>缓存延时双删</strong>策略就好啦？什么是延时双删呢？</p>
          <p><img
              src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc942a69d367464d9e778faf635f6448~tplv-k3u1fbpfcp-watermark.awebp"
              alt="image.png" loading="lazy" class="medium-zoom-image"></p>
          <ol>
            <li>先删除缓存</li>
            <li>再更新数据库</li>
            <li>休眠一会（比如1秒），再次删除缓存。</li>
          </ol>
          <p>这个休眠一会，一般多久呢？都是1秒？</p>
          <blockquote>
            <p>这个休眠时间 = 读业务逻辑数据的耗时 + 几百毫秒。 为了确保读请求结束，写请求可以删除读请求可能带来的缓存脏数据。</p>
          </blockquote>
          <h3 data-id="heading-13">删除缓存重试机制</h3>
          <p>不管是<strong>延时双删</strong>还是<strong>Cache-Aside的先操作数据库再删除缓存</strong>，如果第二步的删除缓存失败呢，删除失败会导致脏数据哦~</p>
          <blockquote>
            <p>删除失败就多删除几次呀,保证删除缓存成功呀~ 所以可以引入<strong>删除缓存重试机制</strong></p>
          </blockquote>
          <p><img
              src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85ce00ef5ad54984a0bbe183bd00b75e~tplv-k3u1fbpfcp-watermark.awebp"
              alt="image.png" loading="lazy" class="medium-zoom-image"></p>
          <ol>
            <li>写请求更新数据库</li>
            <li>缓存因为某些原因，删除失败</li>
            <li>把删除失败的key放到消息队列</li>
            <li>消费消息队列的消息，获取要删除的key</li>
            <li>重试删除缓存操作</li>
          </ol>
          <h3 data-id="heading-14">读取biglog异步删除缓存</h3>
          <p>重试删除缓存机制还可以，就是会造成好多业务代码入侵。其实，还可以通过<strong>数据库的binlog来异步淘汰key</strong>。</p>
          <p><img
              src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f94c4fb98d2f47948f522ddc3d3a10a5~tplv-k3u1fbpfcp-watermark.awebp"
              alt="image.png" loading="lazy" class="medium-zoom-image"></p>
          <p>以mysql为例 可以使用阿里的canal将binlog日志采集发送到MQ队列里面，然后通过ACK机制确认处理这条更新消息，删除缓存，保证数据缓存一致性</p>
          <h3 data-id="heading-15">参考与感谢</h3>
          <ul>
            <li><a
                href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg3NzU5NTIwNg%3D%3D%26mid%3D2247488079%26idx%3D1%26sn%3D49255f6c0c540deeb3333bcf86d6c77c%26chksm%3Dcf21cd66f856447061b5eca47f51199e120a9eaa83fa7546b4bd2667218403ccc97e726ab456%26token%3D840824242%26lang%3Dzh_CN%23rd"
                target="_blank" rel="nofollow noopener noreferrer"
                title="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;mid=2247488079&amp;idx=1&amp;sn=49255f6c0c540deeb3333bcf86d6c77c&amp;chksm=cf21cd66f856447061b5eca47f51199e120a9eaa83fa7546b4bd2667218403ccc97e726ab456&amp;token=840824242&amp;lang=zh_CN#rd"
                ref="nofollow noopener noreferrer">并发环境下，先操作数据库还是先操作缓存？</a></li>
            <li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FbewlUcHL2e6fw2vDrhEDCw"
                target="_blank" rel="nofollow noopener noreferrer"
                title="https://mp.weixin.qq.com/s/bewlUcHL2e6fw2vDrhEDCw"
                ref="nofollow noopener noreferrer">高并发场景下，到底先更新缓存还是先更新数据库？</a></li>
            <li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F-0_ReIv2bp5snq3NUI3P7A"
                target="_blank" rel="nofollow noopener noreferrer"
                title="https://mp.weixin.qq.com/s/-0_ReIv2bp5snq3NUI3P7A"
                ref="nofollow noopener noreferrer">两难！先更新数据库再删缓存？还是先删缓存再更新数据库？</a></li>
            <li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FbWofuM5eS2Q8ylF-4AD0kA"
                target="_blank" rel="nofollow noopener noreferrer"
                title="https://mp.weixin.qq.com/s/bWofuM5eS2Q8ylF-4AD0kA"
                ref="nofollow noopener noreferrer">3种缓存读写策略都不了解？面试很难让你通过啊兄弟</a></li>
          </ul>
          <style>
            .markdown-body pre,
            .markdown-body pre>code.hljs {
              color: #333;
              background: #f8f8f8
            }

            .hljs-comment,
            .hljs-quote {
              color: #998;
              font-style: italic
            }

            .hljs-keyword,
            .hljs-selector-tag,
            .hljs-subst {
              color: #333;
              font-weight: 700
            }

            .hljs-literal,
            .hljs-number,
            .hljs-tag .hljs-attr,
            .hljs-template-variable,
            .hljs-variable {
              color: teal
            }

            .hljs-doctag,
            .hljs-string {
              color: #d14
            }

            .hljs-section,
            .hljs-selector-id,
            .hljs-title {
              color: #900;
              font-weight: 700
            }

            .hljs-subst {
              font-weight: 400
            }

            .hljs-class .hljs-title,
            .hljs-type {
              color: #458;
              font-weight: 700
            }

            .hljs-attribute,
            .hljs-name,
            .hljs-tag {
              color: navy;
              font-weight: 400
            }

            .hljs-link,
            .hljs-regexp {
              color: #009926
            }

            .hljs-bullet,
            .hljs-symbol {
              color: #990073
            }

            .hljs-built_in,
            .hljs-builtin-name {
              color: #0086b3
            }

            .hljs-meta {
              color: #999;
              font-weight: 700
            }

            .hljs-deletion {
              background: #fdd
            }

            .hljs-addition {
              background: #dfd
            }

            .hljs-emphasis {
              font-style: italic
            }

            .hljs-strong {
              font-weight: 700
            }
          </style>
        </div>
      </article>
      <hr class="hr-twill">
      <footer class="footer">
        <ul class="article-other-info">
          <li class="info-item article-categories">
            <i class="iconfont icon-categories"></i>
            <span class="info-key">分类：</span>
            <a href="" class="category info-value">学习记录</a>
          </li>
          <li class="info-item article-tags">
            <i class="iconfont icon-tags"></i>
            <span class="info-key">标签：</span>
            <ul class="tags">
              <li class="tag info-value">JavaScript</li>
              <li class="tag info-value">前端</li>
            </ul>
          </li>
        </ul>

        <div class="like-btn">
          <i class="iconfont icon-likes"></i>
        </div>
      </footer>

    </div>

  </main>
</body>

</html>